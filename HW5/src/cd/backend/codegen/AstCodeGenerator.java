package cd.backend.codegen;

import cd.Config;
import cd.Main;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast;
import cd.ir.Ast.ClassDecl;
import cd.ir.Symbol;

import java.io.Writer;
import java.util.List;

public class AstCodeGenerator {

	protected RegsNeededVisitor rnv;
	
	protected ExprGenerator eg;
	protected StmtGenerator sg;
	
	protected final Main main;
	
	protected final AssemblyEmitter emit;
	protected final RegisterManager rm = new RegisterManager();

	AstCodeGenerator(Main main, Writer out) {
		{
			initMethodData();
		}
		
		this.emit = new AssemblyEmitter(out);
		this.main = main;
		this.rnv = new RegsNeededVisitor();

		this.eg = new ExprGenerator(this);
		this.sg = new StmtGenerator(this);
	}

	protected void debug(String format, Object... args) {
		this.main.debug(format, args);
	}

	public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
		return new AstCodeGenerator(main, out);
	}
	
	protected static final String VAR_PREFIX = "var_";
	
	/**
	 * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
	 * into {@code file}. Throws a {@link RuntimeException} should any I/O error
	 * occur.
	 * 
	 * <p>
	 * The generated file will be divided into three sections:
	 * <ol>
	 * <li>Prologue: Generated by {@link}. This contains any
	 * introductory declarations and the like.
	 * <li>Body: Generated by {@link ExprGenerator}. This contains the main
	 * method definitions.
	 * <li>Epilogue: Generated by {@link} This contains any
	 * final declarations required.
	 * </ol>
	 */
	public void go(List<? extends ClassDecl> astRoots) {
        // Emit some useful string constants:
        emit.emitRaw(Config.DATA_STR_SECTION);
        emit.emitLabel("STR_NL");
        emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
        emit.emitLabel("STR_D");
        emit.emitRaw(Config.DOT_STRING + " \"%d\"");

        emit.emitRaw(Config.TEXT_SECTION);

        Symbol.ClassSymbol mainCls = null;

        emitObjectVtable();
        OffsetsVisitor offsetsVisitor = new OffsetsVisitor(this);
        for (ClassDecl ast : astRoots) {
            offsetsVisitor.visit(ast, null);
        }

        for (ClassDecl ast : astRoots) {
            if (ast.sym.name.equals("Main")) {
                mainCls = ast.sym;
            }
            sg.gen(ast);
        }

        emitBootstrapping(mainCls);
    }

    /** Emits code to start execution of the javali code's Main.main(). */
    private void emitBootstrapping(Symbol.ClassSymbol mainCls) {
        emit.emitRaw(".globl " + Config.MAIN);
        emit.emitLabel(Config.MAIN);

        emitMethodPrefix(0);

        Ast.NewObject mainObj = new Ast.NewObject("Main");
        mainObj.type = mainCls;

        StackManager stackManager = new StackManager(0, this);
        StackManager.Value mainRef = eg.newObject(mainObj, stackManager);

        // The receiver is passed as the first argument.
        emit.emit("pushl", stackManager.reify(mainRef));

        emit.emit("call", "__Main_main");

        emitMethodSuffix(true);
    }

    protected void initMethodData() {
        rm.initRegisters();
    }

    protected void emitMethodPrefix(int stackSize) {
        emit.emit("pushl", RegisterManager.BASE_REG);
        emit.emit("movl", RegisterManager.STACK_REG, RegisterManager.BASE_REG);

        if (Config.systemKind == Config.SystemKind.MACOSX) {
            // Align the stack to 16 bytes.
            emit.emit("andl", AssemblyEmitter.constant(-16), RegisterManager.STACK_REG);
            stackSize = StackManager.alignedTo16(stackSize);
        }

        // Make space on the stack, if required.
        if (stackSize > 0) {
            emit.emit("subl", stackSize, RegisterManager.STACK_REG);
        }
    }

    private void emitObjectVtable() {
        emit.emitLabel(Symbol.ClassSymbol.objectType.getVtableLabel());
    }

	protected void emitMethodSuffix(boolean returnNull) {
		if (returnNull)
			emit.emit("movl", "$0", Register.EAX);
		emit.emitRaw("leave");
		emit.emitRaw("ret");
	}
}